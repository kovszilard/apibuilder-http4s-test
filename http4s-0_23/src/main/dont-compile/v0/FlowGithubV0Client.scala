/**
 * Generated by API Builder - https://www.apibuilder.io
 * Service version: 0.2.53
 * apibuilder 0.15.33 app.apibuilder.io/flow/github/0.2.53/http4s_0_22
 */
package io.flow.github.v0.models {

  final case class Blob(
    content: String,
    encoding: io.flow.github.v0.models.Encoding,
    url: String,
    sha: String,
    size: Long
  )

  final case class BlobCreated(
    url: String,
    sha: String
  )

  final case class BlobForm(
    content: String,
    encoding: io.flow.github.v0.models.Encoding = io.flow.github.v0.models.Encoding.Utf8
  )

  final case class Commit(
    sha: String,
    url: String,
    htmlUrl: String,
    author: io.flow.github.v0.models.Person,
    committer: io.flow.github.v0.models.Person,
    tree: io.flow.github.v0.models.TreeSummary,
    message: String,
    parents: Seq[io.flow.github.v0.models.CommitSummary]
  )

  final case class CommitForm(
    message: String,
    tree: String,
    parents: Seq[String],
    author: io.flow.github.v0.models.Person,
    committer: io.flow.github.v0.models.Person
  )

  final case class CommitResponse(
    sha: String,
    url: String,
    author: io.flow.github.v0.models.Person,
    committer: io.flow.github.v0.models.Person,
    message: String,
    tree: io.flow.github.v0.models.TreeSummary,
    parents: Seq[io.flow.github.v0.models.TreeSummary]
  )

  final case class CommitSummary(
    sha: String,
    url: String
  )

  /**
   * @param content If file, then present
   */

  final case class Contents(
    `type`: io.flow.github.v0.models.ContentsType,
    encoding: io.flow.github.v0.models.Encoding,
    size: Long,
    name: String,
    path: String,
    content: _root_.scala.Option[String] = None,
    sha: String,
    url: String,
    gitUrl: String,
    htmlUrl: String,
    downloadUrl: String
  )

  final case class CreateTreeForm(
    baseTree: String,
    tree: Seq[io.flow.github.v0.models.TreeForm]
  )

  final case class CreateTreeResponse(
    sha: String,
    url: String,
    treeResult: io.flow.github.v0.models.Tree
  )

  final case class Error(
    resource: String,
    field: String,
    code: String
  )

  final case class GithubObject(
    `type`: String,
    sha: String,
    url: String
  )

  /**
   * See https://developer.github.com/v3/repos/hooks/#create-a-hook
   */

  final case class Hook(
    id: Long,
    url: String,
    testUrl: String,
    pingUrl: String,
    name: String,
    events: Seq[io.flow.github.v0.models.HookEvent],
    active: Boolean,
    config: io.flow.github.v0.models.HookConfig,
    updatedAt: _root_.java.time.Instant,
    createdAt: _root_.java.time.Instant
  )

  final case class HookConfig(
    url: _root_.scala.Option[String] = None,
    contentType: _root_.scala.Option[String] = None
  )

  final case class HookForm(
    name: String,
    config: io.flow.github.v0.models.HookConfig,
    events: Seq[io.flow.github.v0.models.HookEvent],
    active: Boolean
  )

  /**
   * @param mode 100644 file (blob), 100755 executable (blob), 040000 subdirectory (tree), 160000
   *        submodule (commit)
   */

  final case class Node(
    path: String,
    mode: String,
    `type`: io.flow.github.v0.models.NodeType,
    size: Long,
    sha: String,
    url: String
  )

  /**
   * @param mode 100644 file (blob), 100755 executable (blob), 040000 subdirectory (tree), 160000
   *        submodule (commit)
   */

  final case class NodeForm(
    path: String,
    mode: String,
    `type`: io.flow.github.v0.models.NodeType,
    sha: String
  )

  final case class Person(
    name: String,
    email: String,
    date: _root_.java.time.Instant
  )

  final case class PullRequest(
    id: Long,
    url: String,
    number: Long,
    htmlUrl: String,
    head: io.flow.github.v0.models.PullRequestHead
  )

  final case class PullRequestForm(
    title: String,
    head: String,
    base: String,
    body: _root_.scala.Option[String] = None
  )

  final case class PullRequestHead(
    ref: String
  )

  final case class Ref(
    ref: String,
    url: String,
    `object`: io.flow.github.v0.models.GithubObject
  )

  final case class RefForm(
    ref: String,
    sha: String
  )

  final case class RefUpdateForm(
    sha: String
  )

  final case class Repository(
    id: Long,
    owner: io.flow.github.v0.models.User,
    name: String,
    fullName: String,
    `private`: Boolean,
    description: _root_.scala.Option[String] = None,
    url: String,
    htmlUrl: String,
    defaultBranch: String
  )

  final case class Tag(
    tag: String,
    sha: String,
    url: String,
    message: String,
    tagger: io.flow.github.v0.models.Tagger,
    `object`: io.flow.github.v0.models.GithubObject
  )

  /**
   * @param `object` The SHA of the git object this is tagging
   */

  final case class TagForm(
    tag: String,
    message: String,
    `object`: String,
    `type`: String = "commit",
    tagger: io.flow.github.v0.models.Tagger
  )

  final case class TagSummary(
    name: String,
    commit: io.flow.github.v0.models.CommitSummary
  )

  final case class Tagger(
    name: String,
    email: String,
    date: _root_.java.time.Instant
  )

  final case class Tree(
    sha: String,
    url: String,
    truncated: Boolean,
    tree: Seq[io.flow.github.v0.models.Node]
  )

  /**
   * @param mode 100644 file (blob), 100755 executable (blob), 040000 subdirectory (tree), 160000
   *        submodule (commit)
   */

  final case class TreeForm(
    path: String,
    mode: String,
    `type`: io.flow.github.v0.models.NodeType,
    sha: _root_.scala.Option[String] = None,
    content: _root_.scala.Option[String] = None
  )

  /**
   * @param mode 100644 file (blob), 100755 executable (blob), 040000 subdirectory (tree), 160000
   *        submodule (commit)
   */

  final case class TreeResult(
    path: String,
    mode: String,
    `type`: io.flow.github.v0.models.NodeType,
    size: Long,
    sha: String,
    url: String
  )

  final case class TreeSummary(
    url: String,
    sha: String
  )

  final case class UnprocessableEntity(
    message: String,
    errors: _root_.scala.Option[Seq[io.flow.github.v0.models.Error]] = None
  )

  final case class User(
    id: Long,
    login: String,
    name: _root_.scala.Option[String] = None,
    email: _root_.scala.Option[String] = None,
    avatarUrl: _root_.scala.Option[String] = None,
    gravatarId: _root_.scala.Option[String] = None,
    url: String,
    htmlUrl: String,
    `type`: io.flow.github.v0.models.OwnerType
  )

  final case class UserEmail(
    email: String,
    verified: Boolean,
    primary: Boolean
  )

  final case class UserOrg(
    login: String
  )
  sealed trait ContentsType extends _root_.scala.Product with _root_.scala.Serializable

  object ContentsType {

    case object File extends ContentsType { override def toString = "file" }
    case object Dir extends ContentsType { override def toString = "dir" }
    case object Symlink extends ContentsType { override def toString = "symlink" }
    case object Submodule extends ContentsType { override def toString = "submodule" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends ContentsType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[ContentsType] = scala.List(File, Dir, Symlink, Submodule)

    private[this]
    val byName: Map[String, ContentsType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): ContentsType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[ContentsType] = byName.get(value.toLowerCase)

  }

  sealed trait Encoding extends _root_.scala.Product with _root_.scala.Serializable

  object Encoding {

    case object Base64 extends Encoding { override def toString = "base64" }
    case object Utf8 extends Encoding { override def toString = "utf-8" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Encoding

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Encoding] = scala.List(Base64, Utf8)

    private[this]
    val byName: Map[String, Encoding] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Encoding = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Encoding] = byName.get(value.toLowerCase)

  }

  sealed trait HookEvent extends _root_.scala.Product with _root_.scala.Serializable

  object HookEvent {

    case object Push extends HookEvent { override def toString = "push" }
    case object PullRequest extends HookEvent { override def toString = "pull_request" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends HookEvent

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[HookEvent] = scala.List(Push, PullRequest)

    private[this]
    val byName: Map[String, HookEvent] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): HookEvent = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[HookEvent] = byName.get(value.toLowerCase)

  }

  sealed trait NodeType extends _root_.scala.Product with _root_.scala.Serializable

  object NodeType {

    case object Blob extends NodeType { override def toString = "blob" }
    case object Tree extends NodeType { override def toString = "tree" }
    case object Commit extends NodeType { override def toString = "commit" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends NodeType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[NodeType] = scala.List(Blob, Tree, Commit)

    private[this]
    val byName: Map[String, NodeType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): NodeType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[NodeType] = byName.get(value.toLowerCase)

  }

  sealed trait OwnerType extends _root_.scala.Product with _root_.scala.Serializable

  object OwnerType {

    case object User extends OwnerType { override def toString = "User" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends OwnerType

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[OwnerType] = scala.List(User)

    private[this]
    val byName: Map[String, OwnerType] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): OwnerType = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[OwnerType] = byName.get(value.toLowerCase)

  }

  sealed trait Visibility extends _root_.scala.Product with _root_.scala.Serializable

  object Visibility {

    case object All extends Visibility { override def toString = "all" }
    case object Public extends Visibility { override def toString = "public" }
    case object Private extends Visibility { override def toString = "private" }
    /**
     * UNDEFINED captures values that are sent either in error or
     * that were added by the server after this library was
     * generated. We want to make it easy and obvious for users of
     * this library to handle this case gracefully.
     *
     * We use all CAPS for the variable name to avoid collisions
     * with the camel cased values above.
     */
    final case class UNDEFINED(override val toString: String) extends Visibility

    /**
     * all returns a list of all the valid, known values. We use
     * lower case to avoid collisions with the camel cased values
     * above.
     */
    val all: scala.List[Visibility] = scala.List(All, Public, Private)

    private[this]
    val byName: Map[String, Visibility] = all.map(x => x.toString.toLowerCase -> x).toMap

    def apply(value: String): Visibility = fromString(value).getOrElse(UNDEFINED(value))

    def fromString(value: String): _root_.scala.Option[Visibility] = byName.get(value.toLowerCase)

  }

}

package io.flow.github.v0.models {

  package object json {
    import io.circe.Decoder._
    import io.circe.Encoder._
    import scala.language.implicitConversions // See below - Make Scala 2.11 Either monadic
    import scala.util.Try
    import io.circe.{Json, JsonObject, Encoder, Decoder, DecodingFailure}
    import io.circe.syntax._
    import io.flow.github.v0.models.json._

    // Make Scala 2.11 Either monadic
    private[v0] implicit def eitherOps[A,B](e: Either[A,B]) = cats.implicits.catsSyntaxEither(e)

    private[v0] implicit val decodeUUID: Decoder[_root_.java.util.UUID] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.util.UUID.fromString(str)))

    private[v0] implicit val encodeUUID: Encoder[_root_.java.util.UUID] =
      Encoder.encodeString.contramap[_root_.java.util.UUID](uuid => uuid.toString)

    private[v0] implicit val decodeInstant: Decoder[_root_.java.time.Instant] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.OffsetDateTime.parse(str).toInstant))

    private[v0] implicit val encodeInstant: Encoder[_root_.java.time.Instant] =
      Encoder.encodeString.contramap[_root_.java.time.Instant](_.toString)

    private[v0] implicit val decodeLocalDate: Decoder[_root_.java.time.LocalDate] =
      Decoder.decodeString.emapTry(str => Try(_root_.java.time.LocalDate.parse(str)))

    private[v0] implicit val encodeLocalDate: Encoder[_root_.java.time.LocalDate] =
      Encoder.encodeString.contramap[_root_.java.time.LocalDate](_.toString)

    implicit val jsonDecoderGithubContentsType: Decoder[io.flow.github.v0.models.ContentsType] =
      Decoder.decodeString.map(io.flow.github.v0.models.ContentsType(_))

    implicit val jsonEncoderGithubContentsType: Encoder[io.flow.github.v0.models.ContentsType] =
      Encoder.encodeString.contramap[io.flow.github.v0.models.ContentsType](_.toString)

    implicit val jsonDecoderGithubEncoding: Decoder[io.flow.github.v0.models.Encoding] =
      Decoder.decodeString.map(io.flow.github.v0.models.Encoding(_))

    implicit val jsonEncoderGithubEncoding: Encoder[io.flow.github.v0.models.Encoding] =
      Encoder.encodeString.contramap[io.flow.github.v0.models.Encoding](_.toString)

    implicit val jsonDecoderGithubHookEvent: Decoder[io.flow.github.v0.models.HookEvent] =
      Decoder.decodeString.map(io.flow.github.v0.models.HookEvent(_))

    implicit val jsonEncoderGithubHookEvent: Encoder[io.flow.github.v0.models.HookEvent] =
      Encoder.encodeString.contramap[io.flow.github.v0.models.HookEvent](_.toString)

    implicit val jsonDecoderGithubNodeType: Decoder[io.flow.github.v0.models.NodeType] =
      Decoder.decodeString.map(io.flow.github.v0.models.NodeType(_))

    implicit val jsonEncoderGithubNodeType: Encoder[io.flow.github.v0.models.NodeType] =
      Encoder.encodeString.contramap[io.flow.github.v0.models.NodeType](_.toString)

    implicit val jsonDecoderGithubOwnerType: Decoder[io.flow.github.v0.models.OwnerType] =
      Decoder.decodeString.map(io.flow.github.v0.models.OwnerType(_))

    implicit val jsonEncoderGithubOwnerType: Encoder[io.flow.github.v0.models.OwnerType] =
      Encoder.encodeString.contramap[io.flow.github.v0.models.OwnerType](_.toString)

    implicit val jsonDecoderGithubVisibility: Decoder[io.flow.github.v0.models.Visibility] =
      Decoder.decodeString.map(io.flow.github.v0.models.Visibility(_))

    implicit val jsonEncoderGithubVisibility: Encoder[io.flow.github.v0.models.Visibility] =
      Encoder.encodeString.contramap[io.flow.github.v0.models.Visibility](_.toString)

    implicit def decodeGithubBlob: Decoder[Blob] = Decoder.instance { c =>
     for {
        content <- c.downField("content").as[String]
        encoding <- c.downField("encoding").as[io.flow.github.v0.models.Encoding]
        url <- c.downField("url").as[String]
        sha <- c.downField("sha").as[String]
        size <- c.downField("size").as[Long]
      } yield {
        Blob(
          content = content,
          encoding = encoding,
          url = url,
          sha = sha,
          size = size
        )
      }
    }

    implicit def encodeGithubBlob: Encoder[Blob] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("content" -> t.content.asJson),
        Some("encoding" -> t.encoding.asJson),
        Some("url" -> t.url.asJson),
        Some("sha" -> t.sha.asJson),
        Some("size" -> t.size.asJson)
      ).flatten)
    }

    implicit def decodeGithubBlobCreated: Decoder[BlobCreated] = Decoder.instance { c =>
     for {
        url <- c.downField("url").as[String]
        sha <- c.downField("sha").as[String]
      } yield {
        BlobCreated(
          url = url,
          sha = sha
        )
      }
    }

    implicit def encodeGithubBlobCreated: Encoder[BlobCreated] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("url" -> t.url.asJson),
        Some("sha" -> t.sha.asJson)
      ).flatten)
    }

    implicit def decodeGithubBlobForm: Decoder[BlobForm] = Decoder.instance { c =>
     for {
        content <- c.downField("content").as[String]
        encoding <- c.downField("encoding").as[io.flow.github.v0.models.Encoding]
      } yield {
        BlobForm(
          content = content,
          encoding = encoding
        )
      }
    }

    implicit def encodeGithubBlobForm: Encoder[BlobForm] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("content" -> t.content.asJson),
        Some("encoding" -> t.encoding.asJson)
      ).flatten)
    }

    implicit def decodeGithubCommit: Decoder[Commit] = Decoder.instance { c =>
     for {
        sha <- c.downField("sha").as[String]
        url <- c.downField("url").as[String]
        htmlUrl <- c.downField("html_url").as[String]
        author <- c.downField("author").as[io.flow.github.v0.models.Person]
        committer <- c.downField("committer").as[io.flow.github.v0.models.Person]
        tree <- c.downField("tree").as[io.flow.github.v0.models.TreeSummary]
        message <- c.downField("message").as[String]
        parents <- c.downField("parents").as[Seq[io.flow.github.v0.models.CommitSummary]]
      } yield {
        Commit(
          sha = sha,
          url = url,
          htmlUrl = htmlUrl,
          author = author,
          committer = committer,
          tree = tree,
          message = message,
          parents = parents
        )
      }
    }

    implicit def encodeGithubCommit: Encoder[Commit] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("sha" -> t.sha.asJson),
        Some("url" -> t.url.asJson),
        Some("html_url" -> t.htmlUrl.asJson),
        Some("author" -> t.author.asJson),
        Some("committer" -> t.committer.asJson),
        Some("tree" -> t.tree.asJson),
        Some("message" -> t.message.asJson),
        Some("parents" -> t.parents.asJson)
      ).flatten)
    }

    implicit def decodeGithubCommitForm: Decoder[CommitForm] = Decoder.instance { c =>
     for {
        message <- c.downField("message").as[String]
        tree <- c.downField("tree").as[String]
        parents <- c.downField("parents").as[Seq[String]]
        author <- c.downField("author").as[io.flow.github.v0.models.Person]
        committer <- c.downField("committer").as[io.flow.github.v0.models.Person]
      } yield {
        CommitForm(
          message = message,
          tree = tree,
          parents = parents,
          author = author,
          committer = committer
        )
      }
    }

    implicit def encodeGithubCommitForm: Encoder[CommitForm] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("message" -> t.message.asJson),
        Some("tree" -> t.tree.asJson),
        Some("parents" -> t.parents.asJson),
        Some("author" -> t.author.asJson),
        Some("committer" -> t.committer.asJson)
      ).flatten)
    }

    implicit def decodeGithubCommitResponse: Decoder[CommitResponse] = Decoder.instance { c =>
     for {
        sha <- c.downField("sha").as[String]
        url <- c.downField("url").as[String]
        author <- c.downField("author").as[io.flow.github.v0.models.Person]
        committer <- c.downField("committer").as[io.flow.github.v0.models.Person]
        message <- c.downField("message").as[String]
        tree <- c.downField("tree").as[io.flow.github.v0.models.TreeSummary]
        parents <- c.downField("parents").as[Seq[io.flow.github.v0.models.TreeSummary]]
      } yield {
        CommitResponse(
          sha = sha,
          url = url,
          author = author,
          committer = committer,
          message = message,
          tree = tree,
          parents = parents
        )
      }
    }

    implicit def encodeGithubCommitResponse: Encoder[CommitResponse] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("sha" -> t.sha.asJson),
        Some("url" -> t.url.asJson),
        Some("author" -> t.author.asJson),
        Some("committer" -> t.committer.asJson),
        Some("message" -> t.message.asJson),
        Some("tree" -> t.tree.asJson),
        Some("parents" -> t.parents.asJson)
      ).flatten)
    }

    implicit def decodeGithubCommitSummary: Decoder[CommitSummary] = Decoder.instance { c =>
     for {
        sha <- c.downField("sha").as[String]
        url <- c.downField("url").as[String]
      } yield {
        CommitSummary(
          sha = sha,
          url = url
        )
      }
    }

    implicit def encodeGithubCommitSummary: Encoder[CommitSummary] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("sha" -> t.sha.asJson),
        Some("url" -> t.url.asJson)
      ).flatten)
    }

    implicit def decodeGithubContents: Decoder[Contents] = Decoder.instance { c =>
     for {
        __type__ <- c.downField("type").as[io.flow.github.v0.models.ContentsType]
        encoding <- c.downField("encoding").as[io.flow.github.v0.models.Encoding]
        size <- c.downField("size").as[Long]
        name <- c.downField("name").as[String]
        path <- c.downField("path").as[String]
        content <- c.downField("content").as[Option[String]]
        sha <- c.downField("sha").as[String]
        url <- c.downField("url").as[String]
        gitUrl <- c.downField("git_url").as[String]
        htmlUrl <- c.downField("html_url").as[String]
        downloadUrl <- c.downField("download_url").as[String]
      } yield {
        Contents(
          `type` = __type__,
          encoding = encoding,
          size = size,
          name = name,
          path = path,
          content = content,
          sha = sha,
          url = url,
          gitUrl = gitUrl,
          htmlUrl = htmlUrl,
          downloadUrl = downloadUrl
        )
      }
    }

    implicit def encodeGithubContents: Encoder[Contents] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("type" -> t.`type`.asJson),
        Some("encoding" -> t.encoding.asJson),
        Some("size" -> t.size.asJson),
        Some("name" -> t.name.asJson),
        Some("path" -> t.path.asJson),
        t.content.map(t => "content" -> t.asJson),
        Some("sha" -> t.sha.asJson),
        Some("url" -> t.url.asJson),
        Some("git_url" -> t.gitUrl.asJson),
        Some("html_url" -> t.htmlUrl.asJson),
        Some("download_url" -> t.downloadUrl.asJson)
      ).flatten)
    }

    implicit def decodeGithubCreateTreeForm: Decoder[CreateTreeForm] = Decoder.instance { c =>
     for {
        baseTree <- c.downField("base_tree").as[String]
        tree <- c.downField("tree").as[Seq[io.flow.github.v0.models.TreeForm]]
      } yield {
        CreateTreeForm(
          baseTree = baseTree,
          tree = tree
        )
      }
    }

    implicit def encodeGithubCreateTreeForm: Encoder[CreateTreeForm] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("base_tree" -> t.baseTree.asJson),
        Some("tree" -> t.tree.asJson)
      ).flatten)
    }

    implicit def decodeGithubCreateTreeResponse: Decoder[CreateTreeResponse] = Decoder.instance { c =>
     for {
        sha <- c.downField("sha").as[String]
        url <- c.downField("url").as[String]
        treeResult <- c.downField("tree_result").as[io.flow.github.v0.models.Tree]
      } yield {
        CreateTreeResponse(
          sha = sha,
          url = url,
          treeResult = treeResult
        )
      }
    }

    implicit def encodeGithubCreateTreeResponse: Encoder[CreateTreeResponse] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("sha" -> t.sha.asJson),
        Some("url" -> t.url.asJson),
        Some("tree_result" -> t.treeResult.asJson)
      ).flatten)
    }

    implicit def decodeGithubError: Decoder[Error] = Decoder.instance { c =>
     for {
        resource <- c.downField("resource").as[String]
        field <- c.downField("field").as[String]
        code <- c.downField("code").as[String]
      } yield {
        Error(
          resource = resource,
          field = field,
          code = code
        )
      }
    }

    implicit def encodeGithubError: Encoder[Error] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("resource" -> t.resource.asJson),
        Some("field" -> t.field.asJson),
        Some("code" -> t.code.asJson)
      ).flatten)
    }

    implicit def decodeGithubGithubObject: Decoder[GithubObject] = Decoder.instance { c =>
     for {
        __type__ <- c.downField("type").as[String]
        sha <- c.downField("sha").as[String]
        url <- c.downField("url").as[String]
      } yield {
        GithubObject(
          `type` = __type__,
          sha = sha,
          url = url
        )
      }
    }

    implicit def encodeGithubGithubObject: Encoder[GithubObject] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("type" -> t.`type`.asJson),
        Some("sha" -> t.sha.asJson),
        Some("url" -> t.url.asJson)
      ).flatten)
    }

    implicit def decodeGithubHook: Decoder[Hook] = Decoder.instance { c =>
     for {
        id <- c.downField("id").as[Long]
        url <- c.downField("url").as[String]
        testUrl <- c.downField("test_url").as[String]
        pingUrl <- c.downField("ping_url").as[String]
        name <- c.downField("name").as[String]
        events <- c.downField("events").as[Seq[io.flow.github.v0.models.HookEvent]]
        active <- c.downField("active").as[Boolean]
        config <- c.downField("config").as[io.flow.github.v0.models.HookConfig]
        updatedAt <- c.downField("updated_at").as[_root_.java.time.Instant]
        createdAt <- c.downField("created_at").as[_root_.java.time.Instant]
      } yield {
        Hook(
          id = id,
          url = url,
          testUrl = testUrl,
          pingUrl = pingUrl,
          name = name,
          events = events,
          active = active,
          config = config,
          updatedAt = updatedAt,
          createdAt = createdAt
        )
      }
    }

    implicit def encodeGithubHook: Encoder[Hook] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("id" -> t.id.asJson),
        Some("url" -> t.url.asJson),
        Some("test_url" -> t.testUrl.asJson),
        Some("ping_url" -> t.pingUrl.asJson),
        Some("name" -> t.name.asJson),
        Some("events" -> t.events.asJson),
        Some("active" -> t.active.asJson),
        Some("config" -> t.config.asJson),
        Some("updated_at" -> t.updatedAt.asJson),
        Some("created_at" -> t.createdAt.asJson)
      ).flatten)
    }

    implicit def decodeGithubHookConfig: Decoder[HookConfig] = Decoder.instance { c =>
     for {
        url <- c.downField("url").as[Option[String]]
        contentType <- c.downField("content_type").as[Option[String]]
      } yield {
        HookConfig(
          url = url,
          contentType = contentType
        )
      }
    }

    implicit def encodeGithubHookConfig: Encoder[HookConfig] = Encoder.instance { t =>
      Json.fromFields(Seq(
        t.url.map(t => "url" -> t.asJson),
        t.contentType.map(t => "content_type" -> t.asJson)
      ).flatten)
    }

    implicit def decodeGithubHookForm: Decoder[HookForm] = Decoder.instance { c =>
     for {
        name <- c.downField("name").as[String]
        config <- c.downField("config").as[io.flow.github.v0.models.HookConfig]
        events <- c.downField("events").as[Seq[io.flow.github.v0.models.HookEvent]]
        active <- c.downField("active").as[Boolean]
      } yield {
        HookForm(
          name = name,
          config = config,
          events = events,
          active = active
        )
      }
    }

    implicit def encodeGithubHookForm: Encoder[HookForm] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("name" -> t.name.asJson),
        Some("config" -> t.config.asJson),
        Some("events" -> t.events.asJson),
        Some("active" -> t.active.asJson)
      ).flatten)
    }

    implicit def decodeGithubNode: Decoder[Node] = Decoder.instance { c =>
     for {
        path <- c.downField("path").as[String]
        mode <- c.downField("mode").as[String]
        __type__ <- c.downField("type").as[io.flow.github.v0.models.NodeType]
        size <- c.downField("size").as[Long]
        sha <- c.downField("sha").as[String]
        url <- c.downField("url").as[String]
      } yield {
        Node(
          path = path,
          mode = mode,
          `type` = __type__,
          size = size,
          sha = sha,
          url = url
        )
      }
    }

    implicit def encodeGithubNode: Encoder[Node] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("path" -> t.path.asJson),
        Some("mode" -> t.mode.asJson),
        Some("type" -> t.`type`.asJson),
        Some("size" -> t.size.asJson),
        Some("sha" -> t.sha.asJson),
        Some("url" -> t.url.asJson)
      ).flatten)
    }

    implicit def decodeGithubNodeForm: Decoder[NodeForm] = Decoder.instance { c =>
     for {
        path <- c.downField("path").as[String]
        mode <- c.downField("mode").as[String]
        __type__ <- c.downField("type").as[io.flow.github.v0.models.NodeType]
        sha <- c.downField("sha").as[String]
      } yield {
        NodeForm(
          path = path,
          mode = mode,
          `type` = __type__,
          sha = sha
        )
      }
    }

    implicit def encodeGithubNodeForm: Encoder[NodeForm] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("path" -> t.path.asJson),
        Some("mode" -> t.mode.asJson),
        Some("type" -> t.`type`.asJson),
        Some("sha" -> t.sha.asJson)
      ).flatten)
    }

    implicit def decodeGithubPerson: Decoder[Person] = Decoder.instance { c =>
     for {
        name <- c.downField("name").as[String]
        email <- c.downField("email").as[String]
        date <- c.downField("date").as[_root_.java.time.Instant]
      } yield {
        Person(
          name = name,
          email = email,
          date = date
        )
      }
    }

    implicit def encodeGithubPerson: Encoder[Person] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("name" -> t.name.asJson),
        Some("email" -> t.email.asJson),
        Some("date" -> t.date.asJson)
      ).flatten)
    }

    implicit def decodeGithubPullRequest: Decoder[PullRequest] = Decoder.instance { c =>
     for {
        id <- c.downField("id").as[Long]
        url <- c.downField("url").as[String]
        number <- c.downField("number").as[Long]
        htmlUrl <- c.downField("html_url").as[String]
        head <- c.downField("head").as[io.flow.github.v0.models.PullRequestHead]
      } yield {
        PullRequest(
          id = id,
          url = url,
          number = number,
          htmlUrl = htmlUrl,
          head = head
        )
      }
    }

    implicit def encodeGithubPullRequest: Encoder[PullRequest] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("id" -> t.id.asJson),
        Some("url" -> t.url.asJson),
        Some("number" -> t.number.asJson),
        Some("html_url" -> t.htmlUrl.asJson),
        Some("head" -> t.head.asJson)
      ).flatten)
    }

    implicit def decodeGithubPullRequestForm: Decoder[PullRequestForm] = Decoder.instance { c =>
     for {
        title <- c.downField("title").as[String]
        head <- c.downField("head").as[String]
        base <- c.downField("base").as[String]
        body <- c.downField("body").as[Option[String]]
      } yield {
        PullRequestForm(
          title = title,
          head = head,
          base = base,
          body = body
        )
      }
    }

    implicit def encodeGithubPullRequestForm: Encoder[PullRequestForm] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("title" -> t.title.asJson),
        Some("head" -> t.head.asJson),
        Some("base" -> t.base.asJson),
        t.body.map(t => "body" -> t.asJson)
      ).flatten)
    }

    implicit def decodeGithubPullRequestHead: Decoder[PullRequestHead] = Decoder.instance { c =>
     for {
        ref <- c.downField("ref").as[String]
      } yield {
        PullRequestHead(
          ref = ref
        )
      }
    }

    implicit def encodeGithubPullRequestHead: Encoder[PullRequestHead] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("ref" -> t.ref.asJson)
      ).flatten)
    }

    implicit def decodeGithubRef: Decoder[Ref] = Decoder.instance { c =>
     for {
        ref <- c.downField("ref").as[String]
        url <- c.downField("url").as[String]
        __object__ <- c.downField("object").as[io.flow.github.v0.models.GithubObject]
      } yield {
        Ref(
          ref = ref,
          url = url,
          `object` = __object__
        )
      }
    }

    implicit def encodeGithubRef: Encoder[Ref] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("ref" -> t.ref.asJson),
        Some("url" -> t.url.asJson),
        Some("object" -> t.`object`.asJson)
      ).flatten)
    }

    implicit def decodeGithubRefForm: Decoder[RefForm] = Decoder.instance { c =>
     for {
        ref <- c.downField("ref").as[String]
        sha <- c.downField("sha").as[String]
      } yield {
        RefForm(
          ref = ref,
          sha = sha
        )
      }
    }

    implicit def encodeGithubRefForm: Encoder[RefForm] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("ref" -> t.ref.asJson),
        Some("sha" -> t.sha.asJson)
      ).flatten)
    }

    implicit def decodeGithubRefUpdateForm: Decoder[RefUpdateForm] = Decoder.instance { c =>
     for {
        sha <- c.downField("sha").as[String]
      } yield {
        RefUpdateForm(
          sha = sha
        )
      }
    }

    implicit def encodeGithubRefUpdateForm: Encoder[RefUpdateForm] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("sha" -> t.sha.asJson)
      ).flatten)
    }

    implicit def decodeGithubRepository: Decoder[Repository] = Decoder.instance { c =>
     for {
        id <- c.downField("id").as[Long]
        owner <- c.downField("owner").as[io.flow.github.v0.models.User]
        name <- c.downField("name").as[String]
        fullName <- c.downField("full_name").as[String]
        __private__ <- c.downField("private").as[Boolean]
        description <- c.downField("description").as[Option[String]]
        url <- c.downField("url").as[String]
        htmlUrl <- c.downField("html_url").as[String]
        defaultBranch <- c.downField("default_branch").as[String]
      } yield {
        Repository(
          id = id,
          owner = owner,
          name = name,
          fullName = fullName,
          `private` = __private__,
          description = description,
          url = url,
          htmlUrl = htmlUrl,
          defaultBranch = defaultBranch
        )
      }
    }

    implicit def encodeGithubRepository: Encoder[Repository] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("id" -> t.id.asJson),
        Some("owner" -> t.owner.asJson),
        Some("name" -> t.name.asJson),
        Some("full_name" -> t.fullName.asJson),
        Some("private" -> t.`private`.asJson),
        t.description.map(t => "description" -> t.asJson),
        Some("url" -> t.url.asJson),
        Some("html_url" -> t.htmlUrl.asJson),
        Some("default_branch" -> t.defaultBranch.asJson)
      ).flatten)
    }

    implicit def decodeGithubTag: Decoder[Tag] = Decoder.instance { c =>
     for {
        tag <- c.downField("tag").as[String]
        sha <- c.downField("sha").as[String]
        url <- c.downField("url").as[String]
        message <- c.downField("message").as[String]
        tagger <- c.downField("tagger").as[io.flow.github.v0.models.Tagger]
        __object__ <- c.downField("object").as[io.flow.github.v0.models.GithubObject]
      } yield {
        Tag(
          tag = tag,
          sha = sha,
          url = url,
          message = message,
          tagger = tagger,
          `object` = __object__
        )
      }
    }

    implicit def encodeGithubTag: Encoder[Tag] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("tag" -> t.tag.asJson),
        Some("sha" -> t.sha.asJson),
        Some("url" -> t.url.asJson),
        Some("message" -> t.message.asJson),
        Some("tagger" -> t.tagger.asJson),
        Some("object" -> t.`object`.asJson)
      ).flatten)
    }

    implicit def decodeGithubTagForm: Decoder[TagForm] = Decoder.instance { c =>
     for {
        tag <- c.downField("tag").as[String]
        message <- c.downField("message").as[String]
        __object__ <- c.downField("object").as[String]
        __type__ <- c.downField("type").as[String]
        tagger <- c.downField("tagger").as[io.flow.github.v0.models.Tagger]
      } yield {
        TagForm(
          tag = tag,
          message = message,
          `object` = __object__,
          `type` = __type__,
          tagger = tagger
        )
      }
    }

    implicit def encodeGithubTagForm: Encoder[TagForm] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("tag" -> t.tag.asJson),
        Some("message" -> t.message.asJson),
        Some("object" -> t.`object`.asJson),
        Some("type" -> t.`type`.asJson),
        Some("tagger" -> t.tagger.asJson)
      ).flatten)
    }

    implicit def decodeGithubTagSummary: Decoder[TagSummary] = Decoder.instance { c =>
     for {
        name <- c.downField("name").as[String]
        commit <- c.downField("commit").as[io.flow.github.v0.models.CommitSummary]
      } yield {
        TagSummary(
          name = name,
          commit = commit
        )
      }
    }

    implicit def encodeGithubTagSummary: Encoder[TagSummary] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("name" -> t.name.asJson),
        Some("commit" -> t.commit.asJson)
      ).flatten)
    }

    implicit def decodeGithubTagger: Decoder[Tagger] = Decoder.instance { c =>
     for {
        name <- c.downField("name").as[String]
        email <- c.downField("email").as[String]
        date <- c.downField("date").as[_root_.java.time.Instant]
      } yield {
        Tagger(
          name = name,
          email = email,
          date = date
        )
      }
    }

    implicit def encodeGithubTagger: Encoder[Tagger] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("name" -> t.name.asJson),
        Some("email" -> t.email.asJson),
        Some("date" -> t.date.asJson)
      ).flatten)
    }

    implicit def decodeGithubTree: Decoder[Tree] = Decoder.instance { c =>
     for {
        sha <- c.downField("sha").as[String]
        url <- c.downField("url").as[String]
        truncated <- c.downField("truncated").as[Boolean]
        tree <- c.downField("tree").as[Seq[io.flow.github.v0.models.Node]]
      } yield {
        Tree(
          sha = sha,
          url = url,
          truncated = truncated,
          tree = tree
        )
      }
    }

    implicit def encodeGithubTree: Encoder[Tree] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("sha" -> t.sha.asJson),
        Some("url" -> t.url.asJson),
        Some("truncated" -> t.truncated.asJson),
        Some("tree" -> t.tree.asJson)
      ).flatten)
    }

    implicit def decodeGithubTreeForm: Decoder[TreeForm] = Decoder.instance { c =>
     for {
        path <- c.downField("path").as[String]
        mode <- c.downField("mode").as[String]
        __type__ <- c.downField("type").as[io.flow.github.v0.models.NodeType]
        sha <- c.downField("sha").as[Option[String]]
        content <- c.downField("content").as[Option[String]]
      } yield {
        TreeForm(
          path = path,
          mode = mode,
          `type` = __type__,
          sha = sha,
          content = content
        )
      }
    }

    implicit def encodeGithubTreeForm: Encoder[TreeForm] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("path" -> t.path.asJson),
        Some("mode" -> t.mode.asJson),
        Some("type" -> t.`type`.asJson),
        t.sha.map(t => "sha" -> t.asJson),
        t.content.map(t => "content" -> t.asJson)
      ).flatten)
    }

    implicit def decodeGithubTreeResult: Decoder[TreeResult] = Decoder.instance { c =>
     for {
        path <- c.downField("path").as[String]
        mode <- c.downField("mode").as[String]
        __type__ <- c.downField("type").as[io.flow.github.v0.models.NodeType]
        size <- c.downField("size").as[Long]
        sha <- c.downField("sha").as[String]
        url <- c.downField("url").as[String]
      } yield {
        TreeResult(
          path = path,
          mode = mode,
          `type` = __type__,
          size = size,
          sha = sha,
          url = url
        )
      }
    }

    implicit def encodeGithubTreeResult: Encoder[TreeResult] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("path" -> t.path.asJson),
        Some("mode" -> t.mode.asJson),
        Some("type" -> t.`type`.asJson),
        Some("size" -> t.size.asJson),
        Some("sha" -> t.sha.asJson),
        Some("url" -> t.url.asJson)
      ).flatten)
    }

    implicit def decodeGithubTreeSummary: Decoder[TreeSummary] = Decoder.instance { c =>
     for {
        url <- c.downField("url").as[String]
        sha <- c.downField("sha").as[String]
      } yield {
        TreeSummary(
          url = url,
          sha = sha
        )
      }
    }

    implicit def encodeGithubTreeSummary: Encoder[TreeSummary] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("url" -> t.url.asJson),
        Some("sha" -> t.sha.asJson)
      ).flatten)
    }

    implicit def decodeGithubUnprocessableEntity: Decoder[UnprocessableEntity] = Decoder.instance { c =>
     for {
        message <- c.downField("message").as[String]
        errors <- c.downField("errors").as[Option[Seq[io.flow.github.v0.models.Error]]]
      } yield {
        UnprocessableEntity(
          message = message,
          errors = errors
        )
      }
    }

    implicit def encodeGithubUnprocessableEntity: Encoder[UnprocessableEntity] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("message" -> t.message.asJson),
        t.errors.map(t => "errors" -> t.asJson)
      ).flatten)
    }

    implicit def decodeGithubUser: Decoder[User] = Decoder.instance { c =>
     for {
        id <- c.downField("id").as[Long]
        login <- c.downField("login").as[String]
        name <- c.downField("name").as[Option[String]]
        email <- c.downField("email").as[Option[String]]
        avatarUrl <- c.downField("avatar_url").as[Option[String]]
        gravatarId <- c.downField("gravatar_id").as[Option[String]]
        url <- c.downField("url").as[String]
        htmlUrl <- c.downField("html_url").as[String]
        __type__ <- c.downField("type").as[io.flow.github.v0.models.OwnerType]
      } yield {
        User(
          id = id,
          login = login,
          name = name,
          email = email,
          avatarUrl = avatarUrl,
          gravatarId = gravatarId,
          url = url,
          htmlUrl = htmlUrl,
          `type` = __type__
        )
      }
    }

    implicit def encodeGithubUser: Encoder[User] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("id" -> t.id.asJson),
        Some("login" -> t.login.asJson),
        t.name.map(t => "name" -> t.asJson),
        t.email.map(t => "email" -> t.asJson),
        t.avatarUrl.map(t => "avatar_url" -> t.asJson),
        t.gravatarId.map(t => "gravatar_id" -> t.asJson),
        Some("url" -> t.url.asJson),
        Some("html_url" -> t.htmlUrl.asJson),
        Some("type" -> t.`type`.asJson)
      ).flatten)
    }

    implicit def decodeGithubUserEmail: Decoder[UserEmail] = Decoder.instance { c =>
     for {
        email <- c.downField("email").as[String]
        verified <- c.downField("verified").as[Boolean]
        primary <- c.downField("primary").as[Boolean]
      } yield {
        UserEmail(
          email = email,
          verified = verified,
          primary = primary
        )
      }
    }

    implicit def encodeGithubUserEmail: Encoder[UserEmail] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("email" -> t.email.asJson),
        Some("verified" -> t.verified.asJson),
        Some("primary" -> t.primary.asJson)
      ).flatten)
    }

    implicit def decodeGithubUserOrg: Decoder[UserOrg] = Decoder.instance { c =>
     for {
        login <- c.downField("login").as[String]
      } yield {
        UserOrg(
          login = login
        )
      }
    }

    implicit def encodeGithubUserOrg: Encoder[UserOrg] = Encoder.instance { t =>
      Json.fromFields(Seq(
        Some("login" -> t.login.asJson)
      ).flatten)
    }
  }
}

package io.flow.github.v0 {
import cats.effect._
import cats.implicits._
import io.circe.syntax._

  object Constants {

    val BaseUrl = "https://api.github.com"
    val Namespace = "io.flow.github.v0"
    val UserAgent = "apibuilder 0.15.33 app.apibuilder.io/flow/github/0.2.53/http4s_0_22"
    val Version = "0.2.53"
    val VersionMajor = 0

  }

  class Client[F[_]: Sync](
    val baseUrl: org.http4s.Uri = org.http4s.Uri.unsafeFromString("https://api.github.com"),
    auth: scala.Option[io.flow.github.v0.Authorization] = None,
    defaultHeaders: Seq[(String, String)] = Nil,
    httpClient: org.http4s.client.Client[F]
  ) extends interfaces.Client[F] {
    import org.http4s.Response
    import io.flow.github.v0.models.json._


    def blobs: Blobs[F] = Blobs

    def commits: Commits[F] = Commits

    def contents: Contents[F] = Contents

    def hooks: Hooks[F] = Hooks

    def pullRequests: PullRequests[F] = PullRequests

    def refs: Refs[F] = Refs

    def repositories: Repositories[F] = Repositories

    def tags: Tags[F] = Tags

    def trees: Trees[F] = Trees

    def userEmails: UserEmails[F] = UserEmails

    def users: Users[F] = Users

    object Blobs extends Blobs[F] {
      import Client._

      override def getBySha(
        owner: String,
        repo: String,
        sha: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Blob] = {
        val urlPath = Seq("repos", owner, repo, "git", "blobs", sha)

        _executeRequest[Unit, io.flow.github.v0.models.Blob]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Blob]("io.flow.github.v0.models.Blob", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def post(
        owner: String,
        repo: String,
        blobForm: io.flow.github.v0.models.BlobForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.BlobCreated] = {
        val urlPath = Seq("repos", owner, repo, "git", "blobs")

        val (payload, formPayload) = (Some(blobForm), None)

        _executeRequest[io.flow.github.v0.models.BlobForm, io.flow.github.v0.models.BlobCreated]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.BlobCreated]("io.flow.github.v0.models.BlobCreated", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 422 =>
            val unprocessable = _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.UnprocessableEntity]("io.flow.github.v0.models.UnprocessableEntity", r)
            ev.flatMap(unprocessable)(body => Sync[F].raiseError(new io.flow.github.v0.errors.UnprocessableEntityResponse(r.headers, r.status.code, None, body)))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 404, 422"))
        }
      }
    }

    object Commits extends Commits[F] {
      import Client._

      override def getBySha(
        owner: String,
        repo: String,
        sha: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Commit] = {
        val urlPath = Seq("repos", owner, repo, "git", "commits", sha)

        _executeRequest[Unit, io.flow.github.v0.models.Commit]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Commit]("io.flow.github.v0.models.Commit", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 422 =>
            val unprocessable = _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.UnprocessableEntity]("io.flow.github.v0.models.UnprocessableEntity", r)
            ev.flatMap(unprocessable)(body => Sync[F].raiseError(new io.flow.github.v0.errors.UnprocessableEntityResponse(r.headers, r.status.code, None, body)))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404, 422"))
        }
      }

      override def post(
        owner: String,
        repo: String,
        commitForm: io.flow.github.v0.models.CommitForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.CommitResponse] = {
        val urlPath = Seq("repos", owner, repo, "git", "commits")

        val (payload, formPayload) = (Some(commitForm), None)

        _executeRequest[io.flow.github.v0.models.CommitForm, io.flow.github.v0.models.CommitResponse]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.CommitResponse]("io.flow.github.v0.models.CommitResponse", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 422 =>
            val unprocessable = _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.UnprocessableEntity]("io.flow.github.v0.models.UnprocessableEntity", r)
            ev.flatMap(unprocessable)(body => Sync[F].raiseError(new io.flow.github.v0.errors.UnprocessableEntityResponse(r.headers, r.status.code, None, body)))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 404, 422"))
        }
      }
    }

    object Contents extends Contents[F] {
      import Client._

      override def getReadme(
        owner: String,
        repo: String,
        ref: String = "main",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Contents] = {
        val urlPath = Seq("repos", owner, repo, "readme")

        val queryParameters = Seq(
          Some("ref" -> ref)
        ).flatten

        _executeRequest[Unit, io.flow.github.v0.models.Contents]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Contents]("io.flow.github.v0.models.Contents", r)
          case r if r.status.code == 401 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 401, 404"))
        }
      }

      override def getContentsByPath(
        owner: String,
        repo: String,
        path: String,
        ref: String = "main",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Contents] = {
        val urlPath = Seq("repos", owner, repo, "contents", path)

        val queryParameters = Seq(
          Some("ref" -> ref)
        ).flatten

        _executeRequest[Unit, io.flow.github.v0.models.Contents]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Contents]("io.flow.github.v0.models.Contents", r)
          case r if r.status.code == 401 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 401, 404"))
        }
      }
    }

    object Hooks extends Hooks[F] {
      import Client._

      override def get(
        owner: String,
        repo: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.Hook]] = {
        val urlPath = Seq("repos", owner, repo, "hooks")

        _executeRequest[Unit, Seq[io.flow.github.v0.models.Hook]]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, Seq[io.flow.github.v0.models.Hook]]("Seq[io.flow.github.v0.models.Hook]", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def getById(
        owner: String,
        repo: String,
        id: Long,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Hook] = {
        val urlPath = Seq("repos", owner, repo, "hooks", id.toString)

        _executeRequest[Unit, io.flow.github.v0.models.Hook]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Hook]("io.flow.github.v0.models.Hook", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def post(
        owner: String,
        repo: String,
        hookForm: io.flow.github.v0.models.HookForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Hook] = {
        val urlPath = Seq("repos", owner, repo, "hooks")

        val (payload, formPayload) = (Some(hookForm), None)

        _executeRequest[io.flow.github.v0.models.HookForm, io.flow.github.v0.models.Hook]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Hook]("io.flow.github.v0.models.Hook", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 422 =>
            val unprocessable = _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.UnprocessableEntity]("io.flow.github.v0.models.UnprocessableEntity", r)
            ev.flatMap(unprocessable)(body => Sync[F].raiseError(new io.flow.github.v0.errors.UnprocessableEntityResponse(r.headers, r.status.code, None, body)))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 404, 422"))
        }
      }

      override def deleteById(
        owner: String,
        repo: String,
        id: Long,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[Unit] = {
        val urlPath = Seq("repos", owner, repo, "hooks", id.toString)

        _executeRequest[Unit, Unit]("DELETE", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 204 => Sync[F].pure(())
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 204, 404"))
        }
      }
    }

    object PullRequests extends PullRequests[F] {
      import Client._

      override def post(
        owner: String,
        repo: String,
        pullRequestForm: io.flow.github.v0.models.PullRequestForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.PullRequest] = {
        val urlPath = Seq("repos", owner, repo, "pulls")

        val (payload, formPayload) = (Some(pullRequestForm), None)

        _executeRequest[io.flow.github.v0.models.PullRequestForm, io.flow.github.v0.models.PullRequest]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.PullRequest]("io.flow.github.v0.models.PullRequest", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 422 =>
            val unprocessable = _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.UnprocessableEntity]("io.flow.github.v0.models.UnprocessableEntity", r)
            ev.flatMap(unprocessable)(body => Sync[F].raiseError(new io.flow.github.v0.errors.UnprocessableEntityResponse(r.headers, r.status.code, None, body)))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 404, 422"))
        }
      }

      override def get(
        owner: String,
        repo: String,
        page: Long = 1L,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.PullRequest]] = {
        val urlPath = Seq("repos", owner, repo, "pulls")

        val queryParameters = Seq(
          Some("page" -> page.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.flow.github.v0.models.PullRequest]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, Seq[io.flow.github.v0.models.PullRequest]]("Seq[io.flow.github.v0.models.PullRequest]", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }
    }

    object Refs extends Refs[F] {
      import Client._

      override def get(
        owner: String,
        repo: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.Ref]] = {
        val urlPath = Seq("repos", owner, repo, "git", "refs")

        _executeRequest[Unit, Seq[io.flow.github.v0.models.Ref]]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, Seq[io.flow.github.v0.models.Ref]]("Seq[io.flow.github.v0.models.Ref]", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def getByRef(
        owner: String,
        repo: String,
        ref: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Ref] = {
        val urlPath = Seq("repos", owner, repo, "git", "refs", ref)

        _executeRequest[Unit, io.flow.github.v0.models.Ref]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Ref]("io.flow.github.v0.models.Ref", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def post(
        owner: String,
        repo: String,
        refForm: io.flow.github.v0.models.RefForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Ref] = {
        val urlPath = Seq("repos", owner, repo, "git", "refs")

        val (payload, formPayload) = (Some(refForm), None)

        _executeRequest[io.flow.github.v0.models.RefForm, io.flow.github.v0.models.Ref]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Ref]("io.flow.github.v0.models.Ref", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 422 =>
            val unprocessable = _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.UnprocessableEntity]("io.flow.github.v0.models.UnprocessableEntity", r)
            ev.flatMap(unprocessable)(body => Sync[F].raiseError(new io.flow.github.v0.errors.UnprocessableEntityResponse(r.headers, r.status.code, None, body)))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 404, 422"))
        }
      }

      override def putByRef(
        owner: String,
        repo: String,
        ref: String,
        refUpdateForm: io.flow.github.v0.models.RefUpdateForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Ref] = {
        val urlPath = Seq("repos", owner, repo, "git", "refs", ref)

        val (payload, formPayload) = (Some(refUpdateForm), None)

        _executeRequest[io.flow.github.v0.models.RefUpdateForm, io.flow.github.v0.models.Ref]("PUT", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Ref]("io.flow.github.v0.models.Ref", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 422 =>
            val unprocessable = _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.UnprocessableEntity]("io.flow.github.v0.models.UnprocessableEntity", r)
            ev.flatMap(unprocessable)(body => Sync[F].raiseError(new io.flow.github.v0.errors.UnprocessableEntityResponse(r.headers, r.status.code, None, body)))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 404, 422"))
        }
      }
    }

    object Repositories extends Repositories[F] {
      import Client._

      override def getUserAndRepos(
        page: Long = 1L,
        visibility: io.flow.github.v0.models.Visibility = io.flow.github.v0.models.Visibility.All,
        affiliation: _root_.scala.Option[String] = None,
        `type`: _root_.scala.Option[String] = None,
        sort: String = "full_name",
        direction: String = "asc",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.Repository]] = {
        val urlPath = Seq("user", "repos")

        val queryParameters = Seq(
          Some("page" -> page.toString),
          Some("visibility" -> visibility.toString),
          affiliation.map("affiliation" -> _),
          `type`.map("type" -> _),
          Some("sort" -> sort),
          Some("direction" -> direction)
        ).flatten

        _executeRequest[Unit, Seq[io.flow.github.v0.models.Repository]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, Seq[io.flow.github.v0.models.Repository]]("Seq[io.flow.github.v0.models.Repository]", r)
          case r if r.status.code == 401 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 401"))
        }
      }

      override def getUsersAndReposByUsername(
        username: String,
        page: Long = 1L,
        `type`: String = "owner",
        sort: String = "full_name",
        direction: String = "asc",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.Repository]] = {
        val urlPath = Seq("users", username, "repos")

        val queryParameters = Seq(
          Some("page" -> page.toString),
          Some("type" -> `type`),
          Some("sort" -> sort),
          Some("direction" -> direction)
        ).flatten

        _executeRequest[Unit, Seq[io.flow.github.v0.models.Repository]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, Seq[io.flow.github.v0.models.Repository]]("Seq[io.flow.github.v0.models.Repository]", r)
          case r if r.status.code == 401 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 401"))
        }
      }

      override def getOrgsAndReposByOrg(
        org: String,
        page: Long = 1L,
        `type`: String = "all",
        sort: String = "full_name",
        direction: String = "asc",
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.Repository]] = {
        val urlPath = Seq("orgs", org, "repos")

        val queryParameters = Seq(
          Some("page" -> page.toString),
          Some("type" -> `type`),
          Some("sort" -> sort),
          Some("direction" -> direction)
        ).flatten

        _executeRequest[Unit, Seq[io.flow.github.v0.models.Repository]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, Seq[io.flow.github.v0.models.Repository]]("Seq[io.flow.github.v0.models.Repository]", r)
          case r if r.status.code == 401 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 401"))
        }
      }
    }

    object Tags extends Tags[F] {
      import Client._

      override def getTags(
        owner: String,
        repo: String,
        page: Long = 1L,
        perPage: Long = 30L,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.TagSummary]] = {
        val urlPath = Seq("repos", owner, repo, "tags")

        val queryParameters = Seq(
          Some("page" -> page.toString),
          Some("per_page" -> perPage.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.flow.github.v0.models.TagSummary]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, Seq[io.flow.github.v0.models.TagSummary]]("Seq[io.flow.github.v0.models.TagSummary]", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def getTagsBySha(
        owner: String,
        repo: String,
        sha: String,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Tag] = {
        val urlPath = Seq("repos", owner, repo, "tags", sha)

        _executeRequest[Unit, io.flow.github.v0.models.Tag]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Tag]("io.flow.github.v0.models.Tag", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 404"))
        }
      }

      override def postGitAndTags(
        owner: String,
        repo: String,
        tagForm: io.flow.github.v0.models.TagForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Tag] = {
        val urlPath = Seq("repos", owner, repo, "git", "tags")

        val (payload, formPayload) = (Some(tagForm), None)

        _executeRequest[io.flow.github.v0.models.TagForm, io.flow.github.v0.models.Tag]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.Tag]("io.flow.github.v0.models.Tag", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 422 =>
            val unprocessable = _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.UnprocessableEntity]("io.flow.github.v0.models.UnprocessableEntity", r)
            ev.flatMap(unprocessable)(body => Sync[F].raiseError(new io.flow.github.v0.errors.UnprocessableEntityResponse(r.headers, r.status.code, None, body)))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 404, 422"))
        }
      }
    }

    object Trees extends Trees[F] {
      import Client._

      override def post(
        owner: String,
        repo: String,
        createTreeForm: io.flow.github.v0.models.CreateTreeForm,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.CreateTreeResponse] = {
        val urlPath = Seq("repos", owner, repo, "git", "trees")

        val (payload, formPayload) = (Some(createTreeForm), None)

        _executeRequest[io.flow.github.v0.models.CreateTreeForm, io.flow.github.v0.models.CreateTreeResponse]("POST", path = urlPath, body = payload, formBody = formPayload, requestHeaders = requestHeaders) {
          case r if r.status.code == 201 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.CreateTreeResponse]("io.flow.github.v0.models.CreateTreeResponse", r)
          case r if r.status.code == 404 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r if r.status.code == 422 =>
            val unprocessable = _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.UnprocessableEntity]("io.flow.github.v0.models.UnprocessableEntity", r)
            ev.flatMap(unprocessable)(body => Sync[F].raiseError(new io.flow.github.v0.errors.UnprocessableEntityResponse(r.headers, r.status.code, None, body)))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 201, 404, 422"))
        }
      }
    }

    object UserEmails extends UserEmails[F] {
      import Client._

      override def get(
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.UserEmail]] = {
        val urlPath = Seq("user", "emails")

        _executeRequest[Unit, Seq[io.flow.github.v0.models.UserEmail]]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, Seq[io.flow.github.v0.models.UserEmail]]("Seq[io.flow.github.v0.models.UserEmail]", r)
          case r if r.status.code == 401 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 401"))
        }
      }
    }

    object Users extends Users[F] {
      import Client._

      override def getUser(
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.User] = {
        val urlPath = Seq("user")

        _executeRequest[Unit, io.flow.github.v0.models.User]("GET", path = urlPath, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, io.flow.github.v0.models.User]("io.flow.github.v0.models.User", r)
          case r if r.status.code == 401 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 401"))
        }
      }

      override def getUserAndOrgs(
        page: Long = 1L,
        perPage: _root_.scala.Option[Long] = None,
        requestHeaders: Seq[(String, String)] = Nil
      )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.UserOrg]] = {
        val urlPath = Seq("user", "orgs")

        val queryParameters = Seq(
          Some("page" -> page.toString),
          perPage.map("per_page" -> _.toString)
        ).flatten

        _executeRequest[Unit, Seq[io.flow.github.v0.models.UserOrg]]("GET", path = urlPath, queryParameters = queryParameters, requestHeaders = requestHeaders) {
          case r if r.status.code == 200 => _root_.io.flow.github.v0.Client.parseJson[F, Seq[io.flow.github.v0.models.UserOrg]]("Seq[io.flow.github.v0.models.UserOrg]", r)
          case r if r.status.code == 401 => Sync[F].raiseError(new io.flow.github.v0.errors.UnitResponse(r.status.code))
          case r => Sync[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Unsupported response code[${r.status.code}]. Expected: 200, 401"))
        }
      }
    }

    private lazy val defaultApiHeaders = Seq(
      ("User-Agent", Constants.UserAgent),
      ("X-Apidoc-Version", Constants.Version),
      ("X-Apidoc-Version-Major", Constants.VersionMajor.toString)
    )

    def apiHeaders: Seq[(String, String)] = defaultApiHeaders

    def modifyRequest(request: org.http4s.Request[F]): org.http4s.Request[F] = request

    implicit def circeJsonEncoder[A](implicit encoder: io.circe.Encoder[A], ev: Sync[F]) = org.http4s.circe.jsonEncoderOf[F, A]

    def _executeRequest[T, U](
      method: String,
      path: Seq[String],
      queryParameters: Seq[(String, String)] = Nil,
      requestHeaders: Seq[(String, String)] = Nil,
      body: Option[T] = None,
      formBody : Option[org.http4s.UrlForm] = None
    )(handler: org.http4s.Response[F] => F[U]
    )(implicit encoder: io.circe.Encoder[T]): F[U] = {
      import org.http4s.QueryParamEncoder._

      val m = org.http4s.Method.fromString(method) match {
        case Right(m) => m
        case Left(e) => sys.error(e.toString)
      }

      val headers = org.http4s.Headers((
        apiHeaders ++
        defaultHeaders ++
        requestHeaders
      ).groupBy(_._1).map { case (k, l) => org.http4s.Header.Raw(org.typelevel.ci.CIString(k), l.last._2) }.toList)

      val queryMap = queryParameters.groupBy(_._1).map { case (k, v) => k -> v.map(_._2) }
      val uri = path.foldLeft(baseUrl){ case (uri, segment) => uri / segment }.setQueryParams(queryMap)

      val request = org.http4s.Request[F](method = m,
                                       uri = uri,
                                       headers = headers)

      val reqAndMaybeAuth = auth.fold(request) {
        case Authorization.Basic(username, passwordOpt) => {
          val userpass = s"$username:${passwordOpt.getOrElse("")}"
          val token = java.util.Base64.getEncoder.encodeToString(userpass.getBytes(java.nio.charset.StandardCharsets.ISO_8859_1))
          request.putHeaders(org.http4s.Header.Raw(org.typelevel.ci.CIString("Authorization"), s"Basic $token"))
        }
        case a => sys.error("Invalid authorization scheme[" + a.getClass + "]")
      }

      val reqAndMaybeAuthAndBody =
        if (formBody.nonEmpty) formBody.fold(reqAndMaybeAuth)(reqAndMaybeAuth.withEntity)
        else body.fold(reqAndMaybeAuth)(reqAndMaybeAuth.withEntity)

      httpClient.fetch(modifyRequest(reqAndMaybeAuthAndBody))(handler)
    }
  }

  object Client {
    import cats.effect._
    import models.json._
    import org.http4s.EntityDecoder
    import org.http4s.DecodeFailure

    implicit def circeJsonDecoder[F[_]: Concurrent, A](implicit decoder: io.circe.Decoder[A]): EntityDecoder[F, A] = org.http4s.circe.jsonOf[F, A]

    def parseJson[F[_]: Concurrent, T](
      className: String,
      r: org.http4s.Response[F]
    )(implicit entityDecoder: EntityDecoder[F, T]): F[T] = r.attemptAs[T].value.flatMap {
      case Right(value) => Concurrent[F].pure(value)
      case Left(error: DecodeFailure) => Concurrent[F].raiseError(new io.flow.github.v0.errors.FailedRequest(r.status.code, s"Invalid json for class[" + className + "]", None, error))
    }
  }

  sealed trait Authorization extends _root_.scala.Product with _root_.scala.Serializable
  object Authorization {
    final case class Basic(username: String, password: Option[String] = None) extends Authorization
  }

  package interfaces {

    trait Client[F[_]] {
      def baseUrl: org.http4s.Uri
      def blobs: io.flow.github.v0.Blobs[F]
      def commits: io.flow.github.v0.Commits[F]
      def contents: io.flow.github.v0.Contents[F]
      def hooks: io.flow.github.v0.Hooks[F]
      def pullRequests: io.flow.github.v0.PullRequests[F]
      def refs: io.flow.github.v0.Refs[F]
      def repositories: io.flow.github.v0.Repositories[F]
      def tags: io.flow.github.v0.Tags[F]
      def trees: io.flow.github.v0.Trees[F]
      def userEmails: io.flow.github.v0.UserEmails[F]
      def users: io.flow.github.v0.Users[F]
    }

  }

  trait Blobs[F[_]] {
    def getBySha(
      owner: String,
      repo: String,
      sha: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Blob]

    def post(
      owner: String,
      repo: String,
      blobForm: io.flow.github.v0.models.BlobForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.BlobCreated]
  }

  trait Commits[F[_]] {
    def getBySha(
      owner: String,
      repo: String,
      sha: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Commit]

    def post(
      owner: String,
      repo: String,
      commitForm: io.flow.github.v0.models.CommitForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.CommitResponse]
  }

  trait Contents[F[_]] {
    def getReadme(
      owner: String,
      repo: String,
      ref: String = "main",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Contents]

    def getContentsByPath(
      owner: String,
      repo: String,
      path: String,
      ref: String = "main",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Contents]
  }

  trait Hooks[F[_]] {
    def get(
      owner: String,
      repo: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.Hook]]

    def getById(
      owner: String,
      repo: String,
      id: Long,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Hook]

    def post(
      owner: String,
      repo: String,
      hookForm: io.flow.github.v0.models.HookForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Hook]

    def deleteById(
      owner: String,
      repo: String,
      id: Long,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[Unit]
  }

  trait PullRequests[F[_]] {
    def post(
      owner: String,
      repo: String,
      pullRequestForm: io.flow.github.v0.models.PullRequestForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.PullRequest]

    def get(
      owner: String,
      repo: String,
      page: Long = 1L,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.PullRequest]]
  }

  trait Refs[F[_]] {
    def get(
      owner: String,
      repo: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.Ref]]

    def getByRef(
      owner: String,
      repo: String,
      ref: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Ref]

    def post(
      owner: String,
      repo: String,
      refForm: io.flow.github.v0.models.RefForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Ref]

    def putByRef(
      owner: String,
      repo: String,
      ref: String,
      refUpdateForm: io.flow.github.v0.models.RefUpdateForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Ref]
  }

  trait Repositories[F[_]] {
    def getUserAndRepos(
      page: Long = 1L,
      visibility: io.flow.github.v0.models.Visibility = io.flow.github.v0.models.Visibility.All,
      affiliation: _root_.scala.Option[String] = None,
      `type`: _root_.scala.Option[String] = None,
      sort: String = "full_name",
      direction: String = "asc",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.Repository]]

    /**
     * List public repositories for the specified user.
     */
    def getUsersAndReposByUsername(
      username: String,
      page: Long = 1L,
      `type`: String = "owner",
      sort: String = "full_name",
      direction: String = "asc",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.Repository]]

    /**
     * List repositories for the specified org.
     */
    def getOrgsAndReposByOrg(
      org: String,
      page: Long = 1L,
      `type`: String = "all",
      sort: String = "full_name",
      direction: String = "asc",
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.Repository]]
  }

  trait Tags[F[_]] {
    def getTags(
      owner: String,
      repo: String,
      page: Long = 1L,
      perPage: Long = 30L,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.TagSummary]]

    def getTagsBySha(
      owner: String,
      repo: String,
      sha: String,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Tag]

    def postGitAndTags(
      owner: String,
      repo: String,
      tagForm: io.flow.github.v0.models.TagForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.Tag]
  }

  trait Trees[F[_]] {
    def post(
      owner: String,
      repo: String,
      createTreeForm: io.flow.github.v0.models.CreateTreeForm,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.CreateTreeResponse]
  }

  trait UserEmails[F[_]] {
    def get(
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.UserEmail]]
  }

  trait Users[F[_]] {
    def getUser(
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[io.flow.github.v0.models.User]

    def getUserAndOrgs(
      page: Long = 1L,
      perPage: _root_.scala.Option[Long] = None,
      requestHeaders: Seq[(String, String)] = Nil
    )(implicit ev: Concurrent[F]): F[Seq[io.flow.github.v0.models.UserOrg]]
  }

  package errors {

    final case class UnitResponse(status: Int) extends Exception(s"HTTP $status")

    final case class UnprocessableEntityResponse(
      headers: org.http4s.Headers,
      status: Int,
      message: Option[String] = None,
      body: io.flow.github.v0.models.UnprocessableEntity
    ) extends Exception(s"HTTP $status${message.fold("")(m => s": $m")}"){
      lazy val unprocessableEntity = body
    }

    final case class FailedRequest(responseCode: Int, message: String, requestUri: Option[_root_.java.net.URI] = None, parent: Exception = null) extends _root_.java.lang.Exception(s"HTTP $responseCode: $message", parent)

  }
}